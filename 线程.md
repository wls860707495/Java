# 线程
线程是一个程序内部的顺序控制流，即程序里不同的执行路径。
## 线程的两种创建方式
### 方法一：在Thread类继承
```java
      public class Test {
		    public static void main(String[] args) {
			    Runner1 r = new Runner1();
			    r.start();
			    for(int i=0;i<100;i++){
				    System.out.println("Main: "+i);
			    }
	    	}
	    }
      public class Runner1 extends Thread {
	      public void run(){
		      for(int i = 0;i<100;i++){
		    	System.out.println("Runner: "+ i);
		      }
      	}
      }
```
### 方法二：实现Runnable接口
```java
public class Test {
	public static void main(String[] args) {
		// TODO 自动生成的方法存根
		Runner1 r = new Runner1();
		Thread t = new Thread(r);
		t.start();
		for(int i=0;i<100;i++){
			System.out.println("Main: "+i);
		}
	}

}
public class Runner1 implements Runnable{
	public void run(){
		for(int i = 0;i<100;i++){
			System.out.println("Runner: "+ i);
		}
	}
}
```
在上述两种方法中，实现接口的方法更加灵活，一般实际中均用此来实现。
## 线程状态转换  
调用start()方法时并不会立即运行，而是处于就绪态等待cpu调度，cpu分配一定的时间片来执行此线程，当时间片结束时回到就绪态。在运行态时若有其他事件发生，则会进入阻塞态，等待阻塞解除进入就绪态。


![XIAN CHENG](https://github.com/wls860707495/Java/blob/master/img/xianchen.png) 
## 互斥锁synchronized
java引入对象互斥锁的概念，可以保证共享数据操作的完整性。
下面举例说明互斥锁
```java
public class TestSync implements Runnable{
    Timer timer = new Timer();
	public static void main(String[] args) {
		// TODO 自动生成的方法存根
		TestSync test = new TestSync();
		Thread t1 = new Thread(test);
		Thread t2 = new Thread(test);
        t1.setName("t1");
        t2.setName("t2");
        t1.start();
        t2.start();
	}
	@Override
	public void run() {
		// TODO 自动生成的方法存根
		timer.add(Thread.currentThread().getName());
	}

}
public class Timer {
	private static int num = 0;
	public synchronized void add(String name){      //表示整个方法为同步方法
		//synchronized (this){         //锁定当前线程，synchronized的另一种用法
		num++;
		try{Thread.sleep(1);}
		catch (InterruptedException e){}
			System.out.println(name+",你是第"+num+"个使用timer的线程");
		//}
	}
}
```
运行结果：t1,你是第1个使用timer的线程
t2,你是第2个使用timer的线程  
若不加锁则会在线程“t1”sleep（）时，t2也会改变num，则会出现均为"第2个使用线程"的情况。互斥锁则放置了此类情况的发生，当t1访问Timer时t2需等待t1放锁。  
## 死锁
下面用例子模拟死锁:  
```java
public class TestDeadLock implements Runnable{
	public int flag = 1;
	static Object o1 = new Object(),o2 =new Object();  //两个对象
	public void run(){
		System.out.println("flag" + flag);
		if(flag == 1){
			synchronized(o1){
				try{
					Thread.sleep(500);
				}catch(Exception e){
					e.printStackTrace();
				}
				synchronized(o2){
					System.out.println("1");
				}
			}
		  }	
		if(flag == 0){
			synchronized(o2){
				try{
					Thread.sleep(500);
				}catch(Exception e){
					e.printStackTrace();
				}
				synchronized(o1){
					System.out.println("0");
				}
			}
		  }	
		}
	public static void main(String[] args) {
		// TODO 自动生成的方法存根
		TestDeadLock td1 = new TestDeadLock();
		TestDeadLock td2 = new TestDeadLock();
		td1.flag = 1;								//一个线程类来模拟两线程，flag不同表示线程不同。
		td2.flag = 0;
		Thread t1 = new Thread(td1);
		Thread t2 = new Thread(td2);
		t1.start();
		t2.start();
	}

}
```
运行结果：flag0  
         flag1  
两线程互相形成死锁，无法输出”1“与”0“.
